<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>mhueschen.space - on Plunder</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <nav>
                <a href="../">home</a>
                <a href="../contact.html">contact</a>
                <a href="../archive.html">archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>on Plunder</h1>
            <article>
    <section class="header">
        posted on 2025-01-02
        
            by mhueschen
        
    </section>
    <section>
        <p>previously I linked to <a href="https://sr.ht/~plan/plunder/" class="uri">https://sr.ht/~plan/plunder/</a>, which used to be the public git repository of the main Plunder codebase.
it seems that the page is now private.</p>
<p>I thought it could be helpful to outline some of the main features of Plunder, which in my opinion was/is a very inventive and ingenious attempt to realize <a href="https://urbit.org/">Urbit</a>’s vision and address some of the key deficiencies of Urbit, which seemingly doom it to fall short of its goal.</p>
<p>&lt;&lt; TODO: refine this &gt;&gt;</p>
<ul>
<li>PLAN
<ul>
<li>simple core calculus / representation</li>
</ul></li>
<li>“data jets”
<ul>
<li>a way to “project” between simple but inefficient PLAN representations and “hardware accelerated” efficient, but more complex representations inside the runtime</li>
</ul></li>
<li>“jets”: similar to Urbit’s concept, it is analogous to “data jets” but for functions.
<ul>
<li>“jetting” a PLAN-defined function allows the runtime to use more efficient code to operate on a PLAN value.</li>
<li>a “jet” usually operates on a value which is “data jetted”. for example, an array-length function might be used on an array, and under the hood, Haskell’s <a href="https://hackage.haskell.org/package/vector">Data.Vector</a> can be used.</li>
</ul></li>
<li>code is data
<ul>
<li>Plunder exhibits “true homoiconicity”, arguably moreso than Lisp, because functions (called Laws in PLAN) are normal values and can be modified using other functions. many Lisps &amp; Schemes will output <code>#&lt;procedure:...&gt;</code>, or some such, when attempting to print a function. in PLAN, this is a normal value.</li>
</ul></li>
<li>“immortal” programs
<ul>
<li>because programs are just data, it is possible to create a function which will hold its state internally, receive inputs, and return outputs.</li>
<li>in Haskell, this would be approximately <code>newtype Immortal = Immortal (Input -&gt; (Output, Immortal))</code>.
<ul>
<li>state would accumulate in the “closure” of the function - potentially huge amounts of state, as a decent PLAN runtime would support memory mapping of Pins.</li>
</ul></li>
</ul></li>
<li>event log + snapshots
<ul>
<li>a PLAN runtime is based on an event log of system calls. these are all logged, and periodically a full snapshot is written. if the runtime crashes, resumption is as simple as loading the last snapshot, then replaying all logged events since said snapshot.</li>
<li>imagining an “immortal” program from above - this mechanism allows it to run potentially forever, surviving runtime crashes, power outages, or moves between underlying machines.</li>
<li>(this of course relies on the PLAN representation itself not changing)</li>
</ul></li>
<li>“hardware” devices
<ul>
<li>TODO</li>
</ul></li>
<li>“machines”
<ul>
<li>TODO</li>
</ul></li>
</ul>
<h2 id="pallas-opfn">Pallas / OPFN</h2>
<p>some work publicly lives on via <a href="https://github.com/operating-function/pallas" class="uri">https://github.com/operating-function/pallas</a>.</p>
    </section>
</article>

        </main>

        <footer>
            site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
